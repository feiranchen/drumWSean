
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module drum#(//parameter max_row = 0,
				 parameter stripes = 1)(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		    [17:0]		SW,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// I2C for Audio  //////////
	output		          		I2C_SCLK,
	inout 		          		I2C_SDAT
);

wire	AUD_CTRL_CLK;
wire	DLY_RST;

wire signed [17:0] u_out;

// The data for the DACs
wire signed [17:0] audio_outL, audio_outR ;

assign	AUD_ADCLRCK	=	AUD_DACLRCK;
assign	AUD_XCK		=	AUD_CTRL_CLK;
/*
Reset_Delay			r0	(.iCLK(CLOCK_50),.oRESET(DLY_RST));

Audio_PLL 			p1	(.areset(~DLY_RST),.inclk0(CLOCK_50),.c0(AUD_CTRL_CLK));

I2C_AV_Config 		u3	(	//	Host Side
							.iCLK(CLOCK_50),
							.iRST_N(KEY[0]),
							//	I2C Side
							.I2C_SCLK(I2C_SCLK),
							.I2C_SDAT(I2C_SDAT)	);

AUDIO_DAC_ADC 			u4	(	//	Audio Side
							.oAUD_BCK(AUD_BCLK),
							.oAUD_DATA(AUD_DACDAT),
							.oAUD_LRCK(AUD_DACLRCK),
							.oAUD_inL(audio_inL), // audio data from ADC 
							.oAUD_inR(audio_inR), // audio data from ADC 
							.iAUD_ADCDAT(AUD_ADCDAT),
							.iAUD_extL(u_out[17:2]), // audio data to DAC
							.iAUD_extR(u_out[17:2]), // audio data to DAC
							//	Control Signals
				         .iCLK_18_4(AUD_CTRL_CLK),
							.iRST_N(DLY_RST)
							);
*/

/*
defparam 
			d1.eta = 5'd6,
			d1.rho = 5'd4,
			d1.max_row = 0;
*/
wire [15:0] u_out_out = u_out[17:2];

wire [17:0] liro [stripes:0];//index of right node
wire [17:0] rilo [stripes:0];//index of right node
wire [17:0] out [stripes - 1:0];//index of right node
assign liro[0] = 18'd0;
assign rilo[stripes] = 18'd0;
assign u_out = out[(stripes>>1)];
genvar i;
generate
	for (i=0; i<stripes; i=i+1)
	begin: d
	   defparam node.stripe = i;
	   defparam node.stripes = stripes;
		drum_node node(
				//.clock(AUD_DACLRCK),
				.clock(CLOCK_50),
				.reset(KEY[0]),
				.left_in(liro[i]),
				.right_in(rilo[i+1]),
				.left_out(rilo[i]),
				.right_out(liro[i+1]),
				.out(out[i]),
				.eta(SW[4:0]),
				.rho(SW[9:5]));
	end
endgenerate
endmodule

module drum_node(	
						input  clock,
						input  reset,

						input signed [17:0] left_in,
						input signed [17:0] right_in,
						output reg signed [17:0] left_out,
						output reg signed [17:0] right_out,
						output reg signed [17:0] out,
						
						input signed [4:0] eta,
						input signed [4:0] rho
						);
						
reg signed [6:0] addr_1a;
reg we_1a;
reg signed [17:0] wr_data_1a;
wire signed [17:0] rd_data_1a;

reg signed [6:0] addr_1b;
reg we_1b;
reg signed [17:0] wr_data_1b;
wire signed [17:0] rd_data_1b;

reg signed [6:0] addr_2a;
reg we_2a;
reg signed [17:0] wr_data_2a;
wire signed [17:0] rd_data_2a;

reg signed [6:0] addr_2b;
reg we_2b;
reg signed [17:0] wr_data_2b;
wire signed [17:0] rd_data_2b;			
						
m9kblock d_n_m9k_1(
	.address_a(addr_1a),
	.address_b(addr_1b),
	.clock(clock),
	.data_a(wr_data_1a),
	.data_b(wr_data_1b),
	.wren_a(we_1a),
	.wren_b(we_1b),
	.q_a(rd_data_1a),
	.q_b(rd_data_1b));

m9kblock d_n_m9k_2(
	.address_a(addr_2a),
	.address_b(addr_2b),
	.clock(clock),
	.data_a(wr_data_2a),
	.data_b(wr_data_2b),
	.wren_a(we_2a),
	.wren_b(we_2b),
	.q_a(rd_data_2a),
	.q_b(rd_data_2b));

	//eta = .0002
	//rho = .05
//wire signed [4:0] eta; //log2(1/eta)
//wire signed [4:0] rho; //log2(1/rho)
wire [2:0] max_row;
reg [4:0] state;

//assign eta = 5'd12;
//assign rho = 5'd4;
assign max_row = 3'd3;
parameter stripe = 0;
parameter stripes = 0;
wire signed [2:0] stripe_shift;
wire signed [2:0] row_shift;

assign stripe_shift = (stripe <= (stripes >>> 1)) ? (stripes >>>1) - stripe :  stripe - (stripes >>>1);
assign row_shift = ((addr_1a + 1) <= (max_row >> 1)) ? (max_row >> 1) - (addr_1a + 1) : (addr_1a + 1) - (max_row >> 1);
/*
if (stripe <= (stripes >>>1))
begin
	assign stripe_shift = (stripes >>>1) - stripe;
end else
begin
	assign stripe_shift = stripe - (stripes >>>1);
end
*/
parameter step1=4'd1, step2=4'd2, step3=4'd3, step4=4'd4, reset1=4'd5, reset2=4'd6, reset3=4'd7,
				init1=4'd8, init2=4'd9, init3=4'd10, init4=4'd11;

//reg signed [17:0] u_1;  // u_{i-1, j  }
//reg signed [17:0] u_2;  // u_{i+1, j  }
reg signed [17:0] u_3;  // u_{i  , j-1}
reg signed [17:0] u_4;  // u_{i  , j+1}
reg signed [17:0] u;    // u_{i  , j  }

reg signed [50:0] test1; // doesn't overflow
reg signed [50:0] test2;
reg signed [50:0] test3;
reg signed [50:0] test4;

reg signed [17:0] u_old;
reg signed [17:0] out_display [2:0];

always @(posedge clock)
begin
	if (reset==0)
	begin
		state = reset1;
		//make our shit look gaussian
	end else
	begin
		case(state)
			reset1:
			begin
				out <= 18'd0;
				// writing u and u_old to the m4k blocks at reset
				we_1a<=1'b0;
				we_1b<=1'b0;
				we_2a<=1'b0;
				we_2b<=1'b0;
				addr_1a <= -1;
				addr_1b <= max_row + 1;
				addr_2a <= -1;
				addr_2b <= max_row + 1;
				state <= reset2;
			end
			
			reset2:
			begin
				we_1a<=1'b1;
				we_1b<=1'b1;
				we_2a<=1'b1;
				we_2b<=1'b1;
				
				addr_1a <= addr_1a + 1;
				addr_1b <= addr_1b - 1;
				addr_2a <= addr_2a + 1;
				addr_2b <= addr_2b - 1;

				if ((addr_1a + 1) <= (max_row >> 1))
				begin
				  wr_data_1a <= (18'h1fff >> row_shift) >> stripe_shift;
				  wr_data_1b <= (18'h1fff >> row_shift) >> stripe_shift;
				  //wr_data_1a <= (((18'h0ffff >> (max_row >> 1)) >> stripe_shift) << (addr_1a + 1)) ;
				  //wr_data_1b <= (((18'h0ffff >> (max_row >> 1)) >> stripe_shift) << (addr_1a + 1));
				end else
				begin
				  wr_data_1a <= (18'h1fff >> row_shift) >> stripe_shift;
				  wr_data_1b <= (18'h1fff >> row_shift) >> stripe_shift;
				end
				
				wr_data_2a <= 0;
				wr_data_2b <= 0;
				
				if (addr_1b - addr_1a <= 3)
				begin
				  state <= reset3;
				end
				else
				begin
				  state <= reset2;
				end
			end
			
			
			reset3:
			begin
				//we_1a<=1'b0;
				//we_1b<=1'b0;
				//we_2a<=1'b0;
				//we_2b<=1'b0;
				state <= init1;
			end

			init1:
			begin
				u_3<=0;
				//initialize read of u, u_4 and u_old
				we_1a<=1'b0;
				we_1b<=1'b0;
				we_2a<=1'b0;
				we_2b<=1'b0;
				addr_1a <= 0;
				addr_1b <= 1;
				addr_2a <= 0;
				
				state<=init2;
			end
			
			init2:
			begin
				//wait for read to complete
				state<=init3;
			end
			
			init3:
			begin
				//wait for read to complete
				state<=init4;
			end
			
			init4:
			begin
				we_1a<=1'b0;
				we_1b<=1'b0;
				we_2a<=1'b0;
				we_2b<=1'b0;
				//get u at the beginning of the stripe
				u <= rd_data_1a;
				state<=step1;
			end
			
			step1:
			begin
				//get data from neighbors (we know they're done because we're done too)
				//u_1 <= left_in;
				//u_2 <= right_in;
				
				if (addr_1a <= max_row)
				begin
					addr_1a <= addr_1a;
					u_4 <= rd_data_1b;
				end
				else
				begin
					addr_1a <= 1'b0;
					u_4 <= 0;
				end
				
				u_old <= rd_data_2a;
				we_2a <= 1'b1;
				wr_data_2a <= u;
				
				left_out <= u;
				right_out <= u;
				
				state<=step2;
				// at end of state:
				// u_3: updated
				// u  : updated
				// u_4: updated
				// u_old : updated, written thru
			end
			
			step2:
			begin
				//prepare read for next step1 (reading u_4 and u_old for next node)
				we_1b<=1'b0;
				we_2a<=1'b0;
				
				if (addr_1a < max_row)
				begin
					addr_1b <= addr_1b + 1; 
					addr_2a <= addr_2a + 1;
					u_3 <= u;
				end
				else
				begin
					addr_1b <= 1;
					addr_2a <= 0;
					u_3 <= u_3;
				end

				//get data from neighbors (we know they're done because we're done too)
				//u_1 <= left_in;
				//u_2 <= right_in;
				//calculation
				//u <= ((u_1 + u_2 + u_3 + u_4 - u<<<2)>>>log2b + u<<<1 - (u_old)>>>log2b)>>>log2c;
				//u <= ((u_1 + u_2 + u_3 + u_4 - u<<<2)<<<log2b + u<<<1 - (u_old)<<<log2c)<<<log2a;
				//u <= ((u_1 + u_2 + u_3 + u_4 - 4*u)>>>4 + 2 * u - (u_old));
				
				//y = ((u_1 + u_2 + u_3 + u_4 - u<<<2) >>> rho);
				//u = y - (y >>> (eta + 1)) + (u <<< 1) - (u >>> eta) - u_old + (u_old >>> eta);
				u <= ((left_in + right_in + u_3 + u_4 - (u<<<2)) >>> rho) 
				  - (((left_in + right_in + u_3 + u_4 - (u<<<2)) >>> rho) >>> (eta + 1)) 
				  + u - u_old + u - (u >>> eta)  + (u_old >>> eta);
				 
				 test1 <= ((left_in + right_in + u_3 + u_4 - (u<<<2)) >>> rho);
				 test2 <= (((left_in + right_in + u_3 + u_4 - (u<<<2)) >>> rho) >>> (eta + 1)) ;
				 test3 <= (u <<< 1) - (u >>> eta);
				 test4 <= (u <<< 1) - (u >>> eta) - u_old + (u_old >>> eta);
				//NOTE REPLACE LEFT_IN AND RIGHT_IN
				//u <= ((left_in + right_in + u_3 + u_4 - (u<<<2)) >>> rho) + (u<<<1) -u_old;
				state<=step3;
				// at end of state:
				// u_3: updated
				// u : updated NOT written thru
				// u_4 NOT updated
				// u_old :NOT updated NOT written thru
			end

			step3:
			begin
				we_1a <= 1'b1;
				wr_data_1a <= u;
				
				if (addr_1a == (max_row>>>1))
				begin
					out <= u;
				end
				
				out_display[addr_1a] <= u;
				
				if (addr_1a < max_row)
				begin
					u<=u_4;
					state <= step4;
				end else
				begin
					u <= u; //stub
					state <= init1;
				end
			end
			
			
			step4:
			begin
			  addr_1a <= addr_1a + 1;
			  state <= step1;
			end
		endcase
	end
end
/*
reg signed [17:0] u_1;  // u_{i-1, j  }
reg signed [17:0] u_2;  // u_{i+1, j  }
reg signed [17:0] u_3;  // u_{i  , j-1}
reg signed [17:0] u_4;  // u_{i  , j+1}
reg signed [17:0] u;    // u_{i  , j  }
*/
// read u_* and u and u_old from neighboring m9k blocks and this block first.
// do the following computation
// u = a * (b * (u_1 + u_2 + u_3 + u_4 - 4*u) + 2 * u - c * (u_old));
// write u to m9k block for this node

endmodule
/* TODO:
 * basic parallel
 * math fomulas / fixed point
 * stripes in every unit module
 */

